#include <string.h>
#include <i2c.h>
#include "i2c_api.h"
//#include <uart.h>
//#define print_hex(x) if((x)>9){putcUART1((x)+0x37);}else{putcUART1((x)+0x30);}

// Bit mask for CRC
#define INT_MSB 0x8000
#define CRC_INT 0x8600 /* x^6 + x + 1 where x^6 is the MSB of the int */
#define CRC_REGISTER_SHIFT 9 // 9 bits diff for register shift

// Definitions for the CRC lookup table
#define NUM_CRC_LOOKUP 16
#define INT_4MSB_SHIFT 12

#define BYTE_SIZE 8
#define BYTE_INT_SHIFT 8 // shift to put the MSB of a byte to the MSB of an int

// Message types (placed in MSB 3 bits of the byte)
#define TYPE0 0x00
#define TYPE1 0x20
#define TYPE2 0x40
#define TYPE7 0xE0
#define TYPE7_FULL 0xFF

// I2C API registers
extern volatile unsigned int slaveWriteBuffer[];
extern volatile unsigned int slaveWriteIds[];
extern volatile unsigned int slaveReadBuffer[];
extern volatile unsigned int slaveReadIds[];
volatile unsigned char slaveWriteLen;
volatile unsigned char slaveReadLen;
volatile unsigned char slaveReadUpdated;
volatile unsigned char slaveMessageError;
volatile unsigned char slaveMsgErrorCount;

extern unsigned int tempBuffer[]; /* holds read data temporarily until the crc check passes */

volatile unsigned char nextTransmitChar;

// Keep track of the module state 
static unsigned char _nextOperation, _bytesLeft;
static enum { Idle, Config1, Config2, Data, MerrAndCRC, StopBit } _status;
unsigned char _setEABit;

static unsigned int *_dataPtr; /* Keeps track of which buffer and where to read/write */

/**
 * _crc defines the crc register used to computed the crc. It consists of the
 * most significant n+1 bits in the crc generator polynomial with degree n,
 * in a big endian form (MSB is x^n, MSB-n is x^0).
 *
 * For x^6 + x + 1, the polynomial is represented as [1000|0110|0000|0000] (CRC_INT).
 * The crc register consists of the 'x' in [xxxx|xxx-|----|----].
 * [x^6 x^5 x^4 x^3 | x^2 x^1 x^0 --- | --- --- --- --- | --- --- --- ---]
 *b
 * To calculate the crc:
 *
 * step1: The data bits are shifted into the most significant 8 bits
 *        and xor'ed with the crc register.
 *          This is analogous in polynomial division when we bring down the
 *          next term of the dividend. Normally we bring down the term after 
 *          each division by the divisor is done and then eventually the 
 *          remainder (with the pulled down term) is subtracted by a multiple
 *          of the divisor.
 *
 *          Since the contents of the register is generated by subtracting the 
 *          generator (divisor), the contents represent the subtraction that 
 *          was made to the bits which were brought down. Since we have not 
 *          brought the digits down yet, the bits represent negative values.
 *          xor-ing the bits will essentially bring down the bits while 
 *          subtracting them from the multiples of the generator (divisor)
 *          as in the normal polynomial division.
 *
 *          The bits can be pulled down this late because xor is communicative
 *          and associative. So any xor operation (the subtraction), can be done
 *          at any time as long as it is before the result is needed.
 *
 * step2: The first 4 bits of the register are used to as the key to lookup
 *        the precomputed compiled generator which divides into these 4 bits.
 *
 * step3: After the compiled generator has been retreived it is xor'ed with
 *        the register to produce the new remainder. (note this may produce
 *        bits up to 4 bits outside of the register).
 *
 * step4: The register is shifted up by 4 bits so the next 4 bits can be
 *        processed. (note this will also move any bits outside of the register
 *        into the register).
 *
 * step5: Repeat steps 2-4 to process the next 4 bits of the byte of data.
 */
static unsigned int _crc;

/**
 * The _crcTable stores the crc (positioned as described above) that will be 
 * applied for a message length of 4 bits. This will be used to compute the 
 * crc, 4 bits at a time.
 */
static unsigned int _crcTable[NUM_CRC_LOOKUP];

/* internal static functions to implement this api */
static void slaveReceive();
static void prepSlaveTransmit();
static void generateCrcTable();
inline static void accumCRC(unsigned char);

void I2CSlaveInitialize(unsigned char address, unsigned char slaveReadLength,
		unsigned char slaveWriteLength)
{
	// Initialize crc lookup table and the initial state.
	generateCrcTable();
	_nextOperation = TYPE1; /* default to type 1 */
	slaveMessageError = 0;  /* no error */
	slaveReadUpdated = 0;   /* no new data */
	_setEABit = 0; 			/* don't set the EA bit */
	slaveMsgErrorCount = 0;	/* initialize slaveMsgErrorCount */
	
	slaveReadLen = slaveReadLength;
	slaveWriteLen = slaveWriteLength;
	memset(slaveReadBuffer, 0, slaveReadLen * sizeof(int)); /* clear the read values */

	// Initialize the I2C perhiperal and the slave interrupt.
	I2CADD = address;
	ConfigIntI2C( MI2C_INT_OFF & SI2C_INT_ON & SI2C_INT_PRI_7 ); //highest priority
	OpenI2C(I2C_ON & I2C_IDLE_CON & I2C_CLK_REL & I2C_IPMI_DIS & I2C_7BIT_ADD &
			I2C_SLW_DIS & I2C_SM_DIS & I2C_GCALL_DIS & I2C_STR_EN & I2C_ACK & 
			I2C_ACK_DIS & I2C_RCV_DIS & I2C_STOP_DIS & I2C_RESTART_DIS & 
			I2C_START_DIS, 0x11 );
	I2CSTATbits.I2COV = 0; /* Clear Overflow Indicator */
}

/**
 * Slave I2C ISR
 * must be the highest priority interrupt because it's using shadow registers
 */
void __attribute__((interrupt, shadow, auto_psv)) _SI2CInterrupt ()
{
	IFS0bits.SI2CIF = 0; // Mark that we have handled the slave event
	//putcUART1('!'+slaveMessageError);
	if((!I2CSTATbits.D_A)&I2CSTATbits.RBF){ //interrupt due to address detection
		//at this point we have no reliable way to determine if the last
		//message sent was a success (assuming we were sending a message).
		//We leave it to the receiver to check the CRC.
		
		/* NOTE: the I2CSTATbits.D_A bit is based on the last bit *received*, contrary 
		to the family reference manual "Register 21-2". Thus when we are aksed to 
		transmit data, I2CSTATbits.D_A will always tell us the last byte was an address
		byte. To handle this, we also ensure that the receive buffer (RBF) is full - eg
		it was an address and the address is there for us to process */
		//putcUART1('\r');
		if(I2CSTATbits.R_W){ //ok, so they want to read from us
			//putcUART1('R');
			/* Send how many more bytes we are going to transmit */
			nextTransmitChar = (((_nextOperation == TYPE1)?slaveReadLen:slaveWriteLen)<<1)+2;
			I2CTRN = nextTransmitChar;	/* data transferred to I2CTRN reg */
			I2CCONbits.SCLREL = 1;	/* Release the clock */
			_crc = 0;
			accumCRC(I2CRCV); /* remove address+R_W bit with read of I2CRCV, also crc */
			accumCRC(nextTransmitChar);
			_status = Config2;
			prepSlaveTransmit();
		}else{ //ok, they're going to write to us, but not quite yet
			//putcUART1('W');
			_crc = 0;
			I2CSTATbits.I2COV = 0; /* Clear Overflow Indicator */
			I2CCONbits.SCLREL = 1; /* Release the clock to allow 1 byte reception*/
			accumCRC(I2CRCV); /* remove address+R_W bit with read of I2CRCV, also crc */
			_status = Config1;
		}
	}else{ //we got new data or they want more data from us
		if(I2CSTATbits.R_W){ //they want more data
			//it seems that the computer's first transmitted byte can tollerate clock 
			//stretching but the ones afterwards can not. (different from SMBus spec)
			//putcUART1('.');
			I2CTRN = nextTransmitChar;	/* data transferred to I2CTRN reg */
			I2CCONbits.SCLREL = 1;	/* Release the clock */
			prepSlaveTransmit();
		}else{ //we got more data
			slaveReceive();
		}
	}
}

static void slaveReceive()
{
	static unsigned char data;

	data = I2CRCV;
	I2CSTATbits.I2COV = 0; /* Clear Overflow Indicator */
	I2CCONbits.SCLREL = 1; /* Release the clock to allow 1 byte reception*/
	
	accumCRC(data);
	switch (_status)
	{
		case Config1:   
			if (data == TYPE7_FULL){
				_status = Config2;
			}else{
				_nextOperation = data << 5; // We are done we don't have to set the status
			}	
			break;
			
		case Config2:		
			_dataPtr = tempBuffer;
			_bytesLeft = slaveReadLen * 2 + 1;
			if(_bytesLeft>1){
				_status = Data;
			}else{
				_status = MerrAndCRC;
			}
			break;
			
		case Data:
			if (_bytesLeft & 1) { // odd means MS bits
				(*_dataPtr) = data << BYTE_SIZE;
			} else {			  // even means LS bits
				(*_dataPtr) |= data; 
				_dataPtr++;
			}

			if ((--_bytesLeft) == 1)  _status = MerrAndCRC;
			break;
			
		case MerrAndCRC:
			if (!_crc) { /* if crc is correct then _crc should be 0 */
				memcpy(slaveReadBuffer, tempBuffer, slaveReadLen * sizeof(int));
				slaveReadUpdated = 1;
				if ( data >> 7 ) /* EA bit */
				{
					slaveMessageError = 0;
				}

				if ( (data >> 6) & 1 ) /* ME bit */
				{
					slaveMsgErrorCount++;
					_setEABit = 1;
				}
			}
			slaveMessageError |= _crc != 0;
			_status = Idle;
			break;

		default:
			slaveMessageError = 1; //message is too long
	}
}

static void prepSlaveTransmit()
{
	//NOTE: first byte (length) is generated in the interrupt.
	switch (_status)
	{
		//case Config1 reassigned as noted below
		case Config2: /* Send [message type : number of values] */
			switch (_nextOperation) {
				case TYPE1: 
					nextTransmitChar = TYPE1 | slaveReadLen;
					_dataPtr = slaveReadIds;
					_bytesLeft = slaveReadLen * 2 + 1;
					break;
					
				case TYPE2: 
					nextTransmitChar = TYPE2 | slaveWriteLen;
					_dataPtr = slaveWriteIds;
					_bytesLeft = slaveWriteLen * 2 + 1;
					break;
					
				case TYPE7: 
					nextTransmitChar = TYPE7_FULL;
					_dataPtr = slaveWriteBuffer;
					_bytesLeft = slaveWriteLen * 2 + 1;
					break;
			}
			if(_bytesLeft>1){
				_status = Data;
			}else{
				_status = MerrAndCRC;
			}
			break;

		case Data: /* Send the data */
			if (_bytesLeft & 1) { // odd means MS bits
				nextTransmitChar = (*_dataPtr) >> BYTE_SIZE;
			} else {			  // even means LS bits
				nextTransmitChar = *_dataPtr;
				_dataPtr++;
			}

			if ((--_bytesLeft) == 1) _status = MerrAndCRC;
			break;

		case MerrAndCRC:        /* Send the message error status and the crc */
			nextTransmitChar = (_setEABit << 7) | ((slaveMessageError & 1) << 6);  /* shift to 2nd MSB */
			_setEABit = 0; 					/* We've just send the EA bit so now we can clear it*/
			
			_crc ^= nextTransmitChar << BYTE_INT_SHIFT; /* shift the data into the crc register */
			
			// Compute the crc of the last two bits of the message.
			if (_crc & INT_MSB) _crc ^= CRC_INT;
			_crc <<= 1;
			if (_crc & INT_MSB) _crc ^= CRC_INT;
			// Don't shift it since we don't have any more bits to guard with the CRC
			
			nextTransmitChar |= _crc >> CRC_REGISTER_SHIFT; /* finally append the crc */
			
			_status = Config1;
			break;
			
		case Config1:        /* hijack Config1 for the last prep after the message */
			_status = StopBit;
			break;

		case StopBit:        /* deal with stop bit interrupt */
			_status = Idle;
			break;

		default:
			slaveMessageError = 1; /* the message has ended already! */
	}
	accumCRC(nextTransmitChar);
}

static void generateCrcTable()
{
	memset(_crcTable, 0, NUM_CRC_LOOKUP * sizeof(int)); /* clear the table */
	
	int key, nbit;
	for (key = 0; key < NUM_CRC_LOOKUP; key++)
	{
		unsigned int remainder = key << 12; /* shift the 4-bit key to the MSB of an int */
		for (nbit = 0; nbit < 4; nbit++)
		{
			if (remainder & INT_MSB)
			{
				_crcTable[key] ^= (CRC_INT >> nbit);
				remainder ^= CRC_INT;
			}
			remainder <<= 1;
		}
	}
}

/**
 * See the comments for the definition of _crc for details.
 */
inline static void accumCRC(unsigned char data)
{
	_crc ^= data << BYTE_INT_SHIFT; /* shift the data amd xor it into the register*/

	/* Use the crc table to accumulate the crc, 4 bits at a time. */
	_crc ^= _crcTable[_crc >> INT_4MSB_SHIFT];
	_crc <<= 4;
	_crc ^= _crcTable[_crc >> INT_4MSB_SHIFT];
	_crc <<= 4;
}

